/**
 * Polyfill for Object.assign
 * @module util/assign
 */
exports = module.exports = (function() {
    'use strict';

    if(Object.assign) {
        // Return native if exists
        return Object.assign;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    /**
     * Basic no-operation method
     * @exports util/assign
     * @param {Object} target - The target Object
     * @param {...*} source - Objects to extend with
     * @return {Object} extended object
     */
    return (target, source) => {
    	var root, symbols;
    	var to = toObject(target);

    	for(var s = 1; s < arguments.length; s++) {
    		root = Object(arguments[s]);

    		for(var key in from) {
    			if(hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if(Object.getOwnPropertySymbols) {
    			symbols = Object.getOwnPropertySymbols(root);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(root, symbols[i])) {
    					to[symbols[i]] = root[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };
})();
