module.exports = (function() {
    'use strict';

    const util = require('util');
    const path = require('path');
    const chalk = require('chalk');

    const EventEmitter = require('events').EventEmitter;
    const Cache = require('./Cache');
    const StoreFactory = require('./util/factory').Store;
    const Type = require('./Type');

    /**
     * Public interface to interact with Storage
     * @constructor Interface
     * @augments EventEmitter
     * @param {Storage} engine - Root Storage object
     * @param {Object?} opts - Configuration object
     */
    function Interface(engine, opts) {
        this.type = Type.Interface;
        this.cache = new Cache();
        this.options = opts || {};
        this.engine = engine;
        this.store = null;
        this.selected = null;
    }

    util.inherits(Interface, EventEmitter);
    Interface.prototype.constructor = Interface;

    /**
     * Use a specific database, must be called before
     * any action is performed with the data.
     * @fires connect
     * @memberof Interface
     * @param  {String} store - Name of storefile
     * @return {this}
     */
    Interface.prototype.use = function(store) {
        let self = this;
        this.selected = store;

        if(typeof store !== 'string') {
            // Skip if no path given to connect to
            throw new Error('No connection string or option connect given!');
        }

        let result = this.engine.Adapter.read({
            path: self.base(`${store}.${this.engine.config.mime}`),
            content: StoreFactory
        });

        this.store = result;
        this.emit('connect', this.selected, this.store);
        return this;
    };

    /**
     * Adding a service to the interface of appdata
     * @memberof Interface
     * @param {Object} service - A service engine
     * @return {Service} Injected service
     */
    Interface.prototype.service = function(service) {
        return service.attach(this);
    };

    /**
     * Get all data from the storage
     * @memberof Interface
     * @return {Object} All values
     */
    Interface.prototype.all = function() {
        this._callCheck();

        return this.store.data;
    };

    /**
     * Get a specific value from the current store
     * @fires get
     * @memberof Interface
     * @param  {String} key - Key for lookup
     * @return {*} The value of the key or undefined
     */
    Interface.prototype.get = function(key) {
        this._callCheck();

        let result = this.store.data[key];
        this.emit('get', key, result);

        return result;
    };

    /**
     * Check if the store contains a key-value pair by this key
     * @fires has
     * @memberof Interface
     * @param  {String} key - Key to lookup
     * @return {Boolean}
     */
    Interface.prototype.has = function(key) {
        this._callCheck();

        let result = this.store.data[key] !== undefined;
        this.emit('has', key, result);

        return result;
    };

    /**
     * Set a new key-value pair in the store
     * @emits set
     * @memberof Interface
     * @param  {String} key - Key to the value
     * @param  {*} value - Value to save for the key
     * @return {*} The value which has been set
     */
    Interface.prototype.set = function(key, value) {
        this._callCheck();

        let result = this.store.data[key] = value;
        this.emit('set', key, value, result);
        this._autosync();

        return result;
    };

    /**
     * Delete a key-value pair from the store
     * @emits delete
     * @memberof Interface
     * @param  {String} key - Key for the pair to delete
     * @return {*} The value from the pair (like Array.shift)
     */
    Interface.prototype.delete = function(key) {
        this._callCheck();

        let saved = this.store.data[key];
        delete this.store.data[key];
        this.emit('delete', key, saved);
        this._autosync();

        return saved;
    };

    /**
     * Drop the whole database
     * @emits drop
     * @memberof Interface
     */
    Interface.prototype.drop = function() {
        this._callCheck();

        this.store.data = {};
        this.emit('drop');
        this._autosync();
    };

    /**
     * Synchronizes the internal database with the
     * corresponding database file.
     * @emits sync
     * @return {Boolean|Object} False if failed, otherwise content
     */
    Interface.prototype.sync = function() {
        let self = this;
        let result = this.engine.Adapter.write({
            path: self.base(`${self.selected}.${this.engine.config.mime}`),
            content: self.store
        });

        this.use(this.selected);
        this.emit('sync', result !== false);
        return result;
    };

    /**
     * Get the base path to the database store object
     * @memberof Interface
     * @param  {String?} filepath - Subpath for file
     * @return {String} Absolute path
     */
    Interface.prototype.base = function(filepath) {
        let base = path.join(this.engine.Manager.structure.data);
        if(typeof filepath === 'string') {
            filepath = path.normalize(filepath);
        }

        return path.join(base, filepath);
    };

    /**
     * Synchronizes the database if autosync has been enabled
     * @private
     * @memberof Interface
     * @return {Boolean|Object} False or content
     */
    Interface.prototype._autosync = function() {
        if(this.options.autosync !== false) {
            return this.sync();
        }
    };

    /**
     * Checks if all data provided which the interface needs
     * to do its work. Private method for internal purposes.
     * @private
     * @memberof Interface
     * @return {Boolean} If the check has passed (true) or not (false)
     */
    Interface.prototype._callCheck = function() {
        if(this.store === null) {
            console.log(chalk.red('No Collection defined use .use(...) to select one'));
            process.exit(3);
            return false;
        } else if(this.engine === null) {
            console.log(chalk.red('No AppData-Store object avaible'));
            process.exit(4);
            return false;
        } else {
            return true;
        }
    };

    return Interface;
})();
